<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Higher Lower Tower - 3D Mockup</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Poppins', sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .interactive { pointer-events: auto; }

        .card-ui {
            width: 80px;
            height: 112px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 8px;
            font-weight: bold;
            transition: transform 0.3s ease;
        }
        .card-ui.red { color: #ef4444; border: 2px solid #ef4444; }
        .card-ui.black { color: #111827; border: 2px solid #111827; }
        .card-ui.back { 
            background: linear-gradient(135deg, #6366f1 0%, #4338ca 100%);
            border: 2px solid white;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
        }
        
        .bg-glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .text-shadow { text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer" class="flex flex-col justify-between p-4">
        <div id="debug-area" class="absolute top-0 left-0 p-2 text-xs text-red-400 font-mono z-50 max-w-sm pointer-events-none"></div>

        <div class="flex justify-between items-start interactive">
            <div class="bg-glass p-3 rounded-xl shadow-lg text-white min-w-[120px]">
                <div class="text-xs opacity-70 uppercase tracking-wider">Floor</div>
                <div class="text-3xl font-bold text-yellow-400" id="floor-display">1</div>
            </div>
            <div class="bg-glass p-3 rounded-xl shadow-lg text-white text-right min-w-[150px]">
                <div class="text-xs opacity-70 uppercase tracking-wider">Score</div>
                <div class="text-2xl font-bold text-green-400 flex items-center justify-end gap-2">
                    <span id="score-display">0</span>
                </div>
            </div>
        </div>

        <div class="absolute top-1/4 left-0 w-full text-center pointer-events-none flex flex-col items-center justify-center z-20">
            <div id="game-message" class="text-4xl md:text-6xl font-black text-white text-shadow transform transition-all duration-300 opacity-0 scale-50">
                LEVEL UP!
            </div>
        </div>

        <div class="absolute top-1/2 left-0 w-full -translate-y-1/2 flex justify-between px-4 md:px-12 pointer-events-none z-0 opacity-90">
            <div class="flex flex-col items-center gap-2">
                <div class="text-white text-sm font-bold bg-black/50 px-2 rounded">CURRENT</div>
                <div id="ui-card-current" class="card-ui black transform -rotate-6">
                    <div class="text-xl">A</div>
                    <div class="text-3xl text-center">♠</div>
                    <div class="text-xl self-end rotate-180">A</div>
                </div>
            </div>
            <div class="flex flex-col items-center gap-2">
                <div class="text-white text-sm font-bold bg-black/50 px-2 rounded">NEXT</div>
                <div id="ui-card-next" class="card-ui back transform rotate-6">?</div>
            </div>
        </div>

        <div class="w-full max-w-md mx-auto mb-6 relative interactive z-30">
            <div id="controls-guess" class="flex gap-4 justify-center transition-all duration-300">
                <button id="btn-higher" class="flex-1 bg-gradient-to-b from-blue-500 to-blue-700 hover:from-blue-400 hover:to-blue-600 text-white font-bold py-4 rounded-2xl shadow-[0_4px_0_rgb(29,78,216)] active:shadow-none active:translate-y-1 transition-all transform hover:scale-105">
                    <div class="text-2xl">▲ HIGHER</div>
                </button>
                <button id="btn-lower" class="flex-1 bg-gradient-to-b from-red-500 to-red-700 hover:from-red-400 hover:to-red-600 text-white font-bold py-4 rounded-2xl shadow-[0_4px_0_rgb(185,28,28)] active:shadow-none active:translate-y-1 transition-all transform hover:scale-105">
                    <div class="text-2xl">▼ LOWER</div>
                </button>
            </div>
            <div id="controls-reset" class="hidden text-center">
                <div class="bg-black/70 p-4 rounded-lg mb-4">
                    <h2 class="text-red-500 text-2xl font-bold">OOPS!</h2>
                    <p class="text-white">Wrong guess. Try this floor again.</p>
                </div>
                <button id="btn-reset" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-4 rounded-2xl shadow-lg text-xl">
                    CONTINUE CLIMB
                </button>
            </div>
        </div>
    </div>

    <script>
        const SETTINGS = {
            floorHeight: 6, 
            cameraOffset: { x: 0, y: 5, z: 16 },
            animationSpeed: 500,
            zIndex: 7.0,
            platformTopOffset: 0.25,
            playerRotation: -Math.PI / 2
        };

        class GameEngine {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(SETTINGS.cameraOffset.x, SETTINGS.cameraOffset.y, SETTINGS.cameraOffset.z);
                this.camera.lookAt(0, SETTINGS.floorHeight/2, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.outputEncoding = THREE.sRGBEncoding; 
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                this.scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 7);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                this.towerGroup = new THREE.Group();
                this.cardGroup = new THREE.Group();
                this.scene.add(this.towerGroup);
                this.scene.add(this.cardGroup);

                this.player = null;
                this.gltfLoader = new THREE.GLTFLoader();
                this.textureLoader = new THREE.TextureLoader();
                
                // Background Sphere - INCREASED SIZE & DISABLED FOG
                const bgGeo = new THREE.SphereGeometry(600, 32, 32);
                const bgMat = new THREE.MeshBasicMaterial({ 
                    side: THREE.BackSide,
                    color: 0xffffff,
                    fog: false // Crucial: Prevents fog from turning the sky blue
                });
                this.backgroundMesh = new THREE.Mesh(bgGeo, bgMat);
                this.scene.add(this.backgroundMesh);
                
                this.backgrounds = {
                    level1: null,
                    level2: null,
                    level3: null
                };

                window.addEventListener('resize', () => this.onResize());
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            loadBackgrounds() {
                const levels = ['bg_1.png', 'bg_2.png', 'bg_3.png'];
                const keys = ['level1', 'level2', 'level3'];
                
                levels.forEach((url, index) => {
                    this.textureLoader.load(
                        url, 
                        (tex) => {
                            console.log(`Loaded background: ${url}`);
                            tex.encoding = THREE.sRGBEncoding; 

                            // --- START FIX: ADJUST TEXTURE MAPPING ---
                            // 1. Enable wrapping so we can shift the image
                            tex.wrapS = THREE.RepeatWrapping;
                            tex.wrapT = THREE.RepeatWrapping;
                            
                            // 2. Repeat horizontally (4x) to reduce stretching and make it look sharper
                            //    Keep vertical (y) at 1 to show the full height of the image
                            tex.repeat.set(4, 1);

                            // 3. Offset Y (Vertical Shift)
                            //    -0.20 pulls the image UP so the bottom (grass) sits at eye level
                            tex.offset.set(0, -0.20); 
                            // --- END FIX ---

                            this.backgrounds[keys[index]] = tex;
                            
                            if(index === 0) {
                                this.updateBackground(1);
                            }
                        },
                        undefined,
                        (err) => console.warn(`Failed to load ${url}:`, err)
                    );
                });
            }

            updateBackground(floor) {
                // CYCLING LOGIC:
                // Floors 1-3: bg_1 (Index 0)
                // Floors 4-6: bg_2 (Index 1)
                // Floors 7-9: bg_3 (Index 2)
                // Floors 10-12: bg_1 (Index 0), etc.
                
                const cycleIndex = Math.floor((floor - 1) / 3) % 3;
                
                let tex;
                if (cycleIndex === 0) tex = this.backgrounds.level1;
                else if (cycleIndex === 1) tex = this.backgrounds.level2;
                else if (cycleIndex === 2) tex = this.backgrounds.level3;

                // Fallback to level1 if the calculated level isn't loaded yet
                if (!tex) tex = this.backgrounds.level1; 

                if (tex && this.backgroundMesh.material.map !== tex) {
                    this.backgroundMesh.material.map = tex;
                    this.backgroundMesh.material.needsUpdate = true;
                    console.log(`Background updated for floor ${floor} -> Image Index ${cycleIndex + 1}`);
                }
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate(time) {
                requestAnimationFrame(this.animate);
                TWEEN.update(time);
                
                // Keep the background centered on the camera so we never go "outside" the sky
                if (this.backgroundMesh) {
                    this.backgroundMesh.position.copy(this.camera.position);
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            initWorld() {
                const towerGeo = new THREE.CylinderGeometry(4.5, 4.5, 300, 32);
                const towerMat = new THREE.MeshStandardMaterial({ color: 0x888888, flatShading: true });
                const tower = new THREE.Mesh(towerGeo, towerMat);
                tower.position.y = 140;
                tower.receiveShadow = true;
                this.towerGroup.add(tower);

                this.loadPlayerModel();
                this.loadBackgrounds();

                for(let i=0; i<50; i++) {
                    this.addPlatform(i);
                }
            }

            fitModelToSize(model, targetHeight) {
                model.updateWorldMatrix(true, true);
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                
                let scaleFactor = 1;
                if (size.y > 0) {
                    scaleFactor = targetHeight / size.y;
                }
                model.scale.set(scaleFactor, scaleFactor, scaleFactor);
                
                model.updateWorldMatrix(true, true);
                const scaledBox = new THREE.Box3().setFromObject(model);
                const center = scaledBox.getCenter(new THREE.Vector3());
                const bottomY = scaledBox.min.y;

                const wrapper = new THREE.Group();
                wrapper.add(model);

                model.position.x = -center.x;
                model.position.y = -bottomY;
                model.position.z = -center.z;

                return wrapper;
            }

            generatePlayerTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 256, 256);
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.roundRect(64, 32, 128, 192, 60);
                ctx.fill();
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.roundRect(74, 80, 45, 30, 10);
                ctx.roundRect(137, 80, 45, 30, 10);
                ctx.fill();
                return new THREE.CanvasTexture(canvas);
            }

            createProceduralPlayer() {
                const tex = this.generatePlayerTexture();
                const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
                const geo = new THREE.PlaneGeometry(2.5, 2.5);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(-1.5, 1.5 + SETTINGS.platformTopOffset, SETTINGS.zIndex); 
                mesh.onBeforeRender = (renderer, scene, camera) => {
                    mesh.quaternion.copy(camera.quaternion);
                };
                return mesh;
            }

            loadPlayerModel() {
                this.player = this.createProceduralPlayer();
                this.scene.add(this.player);

                try {
                    this.gltfLoader.load(
                        'character.glb',
                        (gltf) => {
                            if(this.player) this.scene.remove(this.player);
                            const fixedModel = this.fitModelToSize(gltf.scene, 2.5);
                            this.player = fixedModel;
                            this.player.position.set(-1.5, SETTINGS.platformTopOffset, SETTINGS.zIndex); 
                            this.player.rotation.y = SETTINGS.playerRotation; 
                            this.scene.add(this.player);
                            document.getElementById('debug-area').innerText = ""; 
                        },
                        undefined, 
                        (error) => {
                            console.warn("GLB load failed:", error);
                            if (window.location.protocol === 'file:') {
                                document.getElementById('debug-area').innerHTML = "⚠️ Using Backup Sprite (Browser Blocked 3D File)";
                            }
                        }
                    );
                } catch (e) {
                    console.warn("GLTFLoader exception:", e);
                }
            }

            addPlatform(level) {
                const geo = new THREE.BoxGeometry(3.5, 0.5, 3.5);
                const mat = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const platform = new THREE.Mesh(geo, mat);
                platform.position.set(0, level * SETTINGS.floorHeight, SETTINGS.zIndex);
                platform.castShadow = true;
                platform.receiveShadow = true;
                this.towerGroup.add(platform);
            }

            spawnCard(cardData, isCurrent, floorIndex) {
                return null;
            }

            moveCameraToFloor(floorIndex) {
                const targetY = (floorIndex * SETTINGS.floorHeight) + SETTINGS.cameraOffset.y;
                new TWEEN.Tween(this.camera.position)
                    .to({ y: targetY }, SETTINGS.animationSpeed * 1.2)
                    .easing(TWEEN.Easing.Cubic.InOut)
                    .start();
            }

            playerJumpTo(floorIndex) {
                const endY = (floorIndex * SETTINGS.floorHeight) + SETTINGS.platformTopOffset; 
                
                // Position Jump
                new TWEEN.Tween(this.player.position)
                    .to({ y: endY }, SETTINGS.animationSpeed)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();

                // Squash & Stretch
                new TWEEN.Tween(this.player.scale)
                    .to({ y: 0.8, x: 1.2, z: 1.2 }, SETTINGS.animationSpeed * 0.5)
                    .yoyo(true)
                    .repeat(1)
                    .start();

                // 360 Spin Animation
                // We add 360 degrees (2 * PI) to the current rotation so it spins a full circle
                // and lands facing the original direction.
                const startRot = this.player.rotation.y;
                const endRot = startRot + (Math.PI * 2);
                new TWEEN.Tween(this.player.rotation)
                    .to({ y: endRot }, SETTINGS.animationSpeed)
                    .easing(TWEEN.Easing.Cubic.InOut)
                    .start();
            }

            flipCard(cardMesh) {
                return new Promise(resolve => {
                    if (!cardMesh) { resolve(); return; }
                    new TWEEN.Tween(cardMesh.rotation)
                        .to({ y: 0 }, 300)
                        .easing(TWEEN.Easing.Linear.None)
                        .onComplete(resolve)
                        .start();
                });
            }
            
            clearOldCards(floorLimit) {
                const keepHeight = (floorLimit - 1) * SETTINGS.floorHeight;
                for(let i = this.cardGroup.children.length - 1; i >= 0; i--) {
                    if(this.cardGroup.children[i].position.y < keepHeight) {
                        this.cardGroup.remove(this.cardGroup.children[i]);
                    }
                }
            }
        }

        class GameLogic {
            constructor(engine) {
                this.engine = engine;
                this.deck = [];
                this.currentCard = null;
                this.nextCard = null;
                this.floor = 1;
                this.score = 0;
                this.currentCardMesh = null;
                this.nextCardMesh = null;
                this.initGame();
            }

            initGame() {
                this.floor = 1;
                this.score = 0;
                this.updateUI();
                this.generateDeck();
                this.currentCard = this.drawCard();
                this.nextCard = this.drawCard();

                if(this.engine.player) {
                    this.engine.player.position.set(-1.5, SETTINGS.platformTopOffset, SETTINGS.zIndex);
                }
                this.engine.camera.position.y = SETTINGS.cameraOffset.y;
                this.engine.cardGroup.clear();
                
                // Force check background for floor 1
                this.engine.updateBackground(1);

                this.currentCardMesh = this.engine.spawnCard(this.currentCard, true, 0);
                this.nextCardMesh = this.engine.spawnCard(this.nextCard, false, 0);

                this.updateCardUI();
                this.setPhase('guess');
            }

            retryFloor() {
                this.nextCard = this.drawCard();
                this.currentCardMesh = this.engine.spawnCard(this.currentCard, true, this.floor - 1);
                this.nextCardMesh = this.engine.spawnCard(this.nextCard, false, this.floor - 1);
                this.updateCardUI();
                this.setPhase('guess');
            }

            generateDeck() {
                const suits = [
                    { s: '♥', c: '#ef4444' }, { s: '♦', c: '#ef4444' }, 
                    { s: '♣', c: '#111827' }, { s: '♠', c: '#111827' }
                ];
                const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                this.deck = [];
                for(let d=0; d<5; d++) {
                    for (const suit of suits) {
                        for (let i = 0; i < ranks.length; i++) {
                            this.deck.push({
                                rank: ranks[i],
                                value: i + 2,
                                suitIcon: suit.s,
                                color: suit.c
                            });
                        }
                    }
                }
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            drawCard() {
                if(this.deck.length === 0) this.generateDeck();
                return this.deck.pop();
            }

            async playerGuess(choice) {
                this.setPhase('locked');
                await this.engine.flipCard(this.nextCardMesh);
                this.updateCardUI(true); 

                const currentVal = this.currentCard.value;
                const nextVal = this.nextCard.value;
                let won = false;

                if (choice === 'higher' && nextVal >= currentVal) won = true;
                else if (choice === 'lower' && nextVal <= currentVal) won = true;

                if (won) {
                    setTimeout(() => this.handleWin(), 300);
                } else {
                    setTimeout(() => this.handleLoss(), 500);
                }
            }

            handleWin() {
                this.showMessage("CORRECT!", false);
                this.score += 100 * this.floor;
                this.floor++;
                
                this.engine.playerJumpTo(this.floor - 1);
                this.engine.moveCameraToFloor(this.floor - 1);
                this.engine.updateBackground(this.floor); // Updates BG every 3 floors
                
                this.updateUI();
                setTimeout(() => {
                    this.setupNextRound();
                }, SETTINGS.animationSpeed + 100);
            }

            handleLoss() {
                this.showMessage("TRY AGAIN!", true);
                this.setPhase('gameover');
            }

            setupNextRound() {
                this.currentCard = this.nextCard;
                if (this.nextCardMesh) {
                    this.engine.cardGroup.remove(this.nextCardMesh);
                    this.nextCardMesh = null;
                }
                this.nextCard = this.drawCard();
                const floorIdx = this.floor - 1;
                this.nextCardMesh = this.engine.spawnCard(this.nextCard, false, floorIdx);
                this.engine.clearOldCards(this.floor);
                this.updateCardUI(false); 
                this.setPhase('guess');
            }
            
            continueGame() {
                this.nextCard = this.drawCard();
                if (this.nextCardMesh) {
                    this.engine.cardGroup.remove(this.nextCardMesh);
                    this.nextCardMesh = null;
                }
                this.nextCardMesh = this.engine.spawnCard(this.nextCard, false, this.floor - 1);
                this.updateCardUI(false);
                this.setPhase('guess');
            }

            updateCardUI(revealNext = false) {
                const c = this.currentCard;
                const cEl = document.getElementById('ui-card-current');
                cEl.className = `card-ui transform -rotate-6 ${c.color === '#ef4444' ? 'red' : 'black'}`;
                cEl.innerHTML = `<div class="text-xl">${c.rank}</div><div class="text-3xl text-center">${c.suitIcon}</div><div class="text-xl self-end rotate-180">${c.rank}</div>`;

                const nEl = document.getElementById('ui-card-next');
                if (revealNext) {
                    const n = this.nextCard;
                    nEl.className = `card-ui transform rotate-6 ${n.color === '#ef4444' ? 'red' : 'black'}`;
                    nEl.innerHTML = `<div class="text-xl">${n.rank}</div><div class="text-3xl text-center">${n.suitIcon}</div><div class="text-xl self-end rotate-180">${n.rank}</div>`;
                } else {
                    nEl.className = 'card-ui back transform rotate-6';
                    nEl.innerHTML = '?';
                }
            }

            showMessage(text, isBad = false) {
                const el = document.getElementById('game-message');
                el.innerText = text;
                el.style.color = isBad ? '#ff4444' : '#4ade80';
                el.style.opacity = 1;
                el.style.transform = 'scale(1)';
                setTimeout(() => {
                    el.style.opacity = 0;
                    el.style.transform = 'scale(0.5)';
                }, 1000);
            }

            updateUI() {
                document.getElementById('floor-display').innerText = this.floor;
                document.getElementById('score-display').innerText = this.score;
            }

            setPhase(phase) {
                const guessControls = document.getElementById('controls-guess');
                const resetControls = document.getElementById('controls-reset');
                guessControls.classList.add('hidden');
                resetControls.classList.add('hidden');
                if (phase === 'guess') {
                    guessControls.classList.remove('hidden');
                } else if (phase === 'gameover') {
                    resetControls.classList.remove('hidden');
                }
            }
        }

        const engine = new GameEngine();
        engine.initWorld();
        window.game = new GameLogic(engine);

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('btn-higher').addEventListener('click', () => window.game.playerGuess('higher'));
            document.getElementById('btn-lower').addEventListener('click', () => window.game.playerGuess('lower'));
            document.getElementById('btn-reset').addEventListener('click', () => window.game.continueGame());
        });

    </script>
</body>
</html>
