<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Higher Lower Tower - 3D Mockup</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Poppins', sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* Interactive UI Elements */
        .interactive { pointer-events: auto; }

        /* Card UI Styles */
        .card-ui {
            width: 80px;
            height: 112px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 8px;
            font-weight: bold;
            transition: transform 0.3s ease;
        }
        .card-ui.red { color: #ef4444; border: 2px solid #ef4444; }
        .card-ui.black { color: #111827; border: 2px solid #111827; }
        .card-ui.back { 
            background: linear-gradient(135deg, #6366f1 0%, #4338ca 100%);
            border: 2px solid white;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
        }
        
        /* Gradients */
        .bg-glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .text-shadow { text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
    </style>

    <!-- Three.js, Tween.js, and GLTFLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <!-- 3D Container -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col justify-between p-4">
        
        <!-- Debug/Warning Area -->
        <div id="debug-area" class="absolute top-0 left-0 p-2 text-xs text-red-400 font-mono z-50 max-w-sm pointer-events-none"></div>

        <!-- Header / Stats -->
        <div class="flex justify-between items-start interactive">
            <div class="bg-glass p-3 rounded-xl shadow-lg text-white min-w-[120px]">
                <div class="text-xs opacity-70 uppercase tracking-wider">Floor</div>
                <div class="text-3xl font-bold text-yellow-400" id="floor-display">1</div>
            </div>

            <div class="bg-glass p-3 rounded-xl shadow-lg text-white text-right min-w-[150px]">
                <div class="text-xs opacity-70 uppercase tracking-wider">Score</div>
                <div class="text-2xl font-bold text-green-400 flex items-center justify-end gap-2">
                    <span id="score-display">0</span>
                </div>
            </div>
        </div>

        <!-- Center Message Area -->
        <div class="absolute top-1/4 left-0 w-full text-center pointer-events-none flex flex-col items-center justify-center z-20">
            <div id="game-message" class="text-4xl md:text-6xl font-black text-white text-shadow transform transition-all duration-300 opacity-0 scale-50">
                LEVEL UP!
            </div>
        </div>

        <!-- Card Overlay Area -->
        <div class="absolute top-1/2 left-0 w-full -translate-y-1/2 flex justify-between px-4 md:px-12 pointer-events-none z-0 opacity-90">
            <!-- Left: Current Card -->
            <div class="flex flex-col items-center gap-2">
                <div class="text-white text-sm font-bold bg-black/50 px-2 rounded">CURRENT</div>
                <div id="ui-card-current" class="card-ui black transform -rotate-6">
                    <div class="text-xl">A</div>
                    <div class="text-3xl text-center">♠</div>
                    <div class="text-xl self-end rotate-180">A</div>
                </div>
            </div>

            <!-- Right: Next Card -->
            <div class="flex flex-col items-center gap-2">
                <div class="text-white text-sm font-bold bg-black/50 px-2 rounded">NEXT</div>
                <div id="ui-card-next" class="card-ui back transform rotate-6">
                    ?
                </div>
            </div>
        </div>

        <!-- Footer / Controls -->
        <div class="w-full max-w-md mx-auto mb-6 relative interactive z-30">
            
            <!-- Phase 1: Guessing -->
            <div id="controls-guess" class="flex gap-4 justify-center transition-all duration-300">
                <button onclick="game.playerGuess('higher')" class="flex-1 bg-gradient-to-b from-blue-500 to-blue-700 hover:from-blue-400 hover:to-blue-600 text-white font-bold py-4 rounded-2xl shadow-[0_4px_0_rgb(29,78,216)] active:shadow-none active:translate-y-1 transition-all transform hover:scale-105">
                    <div class="text-2xl">▲ HIGHER</div>
                </button>
                <button onclick="game.playerGuess('lower')" class="flex-1 bg-gradient-to-b from-red-500 to-red-700 hover:from-red-400 hover:to-red-600 text-white font-bold py-4 rounded-2xl shadow-[0_4px_0_rgb(185,28,28)] active:shadow-none active:translate-y-1 transition-all transform hover:scale-105">
                    <div class="text-2xl">▼ LOWER</div>
                </button>
            </div>

            <!-- Phase 3: Game Over -->
            <div id="controls-reset" class="hidden text-center">
                <div class="bg-black/70 p-4 rounded-lg mb-4">
                    <h2 class="text-red-500 text-2xl font-bold">GAME OVER</h2>
                    <p class="text-white">You reached Floor <span id="final-floor">0</span></p>
                </div>
                <button onclick="game.resetGame()" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-4 rounded-2xl shadow-lg text-xl">
                    TRY AGAIN
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Game Settings ---
        const SETTINGS = {
            floorHeight: 6, 
            cameraOffset: { x: 0, y: 5, z: 16 },
            animationSpeed: 500,
            // Platform & Player Depth (Positive Z is closer to camera)
            // Tower is Radius 4.5. Setting this to 7.0 ensures we are safe from clipping.
            zIndex: 7.0,
            // Offset to put feet on TOP of platform (Platform height 0.5 / 2 = 0.25)
            platformTopOffset: 0.25
        };

        // --- Three.js Engine Class ---
        class GameEngine {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // Simple Sky Blue
                this.scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

                // Camera
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(SETTINGS.cameraOffset.x, SETTINGS.cameraOffset.y, SETTINGS.cameraOffset.z);
                this.camera.lookAt(0, SETTINGS.floorHeight/2, 0);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 7);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                // Groups
                this.towerGroup = new THREE.Group();
                this.cardGroup = new THREE.Group();
                this.scene.add(this.towerGroup);
                this.scene.add(this.cardGroup);

                this.player = null;

                // Loaders
                this.gltfLoader = new THREE.GLTFLoader();

                window.addEventListener('resize', () => this.onResize());
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate(time) {
                requestAnimationFrame(this.animate);
                TWEEN.update(time);
                this.renderer.render(this.scene, this.camera);
            }

            initWorld() {
                // 1. Tower (Simple Cylinder)
                const towerGeo = new THREE.CylinderGeometry(4.5, 4.5, 300, 32);
                const towerMat = new THREE.MeshStandardMaterial({ color: 0x888888, flatShading: true });
                const tower = new THREE.Mesh(towerGeo, towerMat);
                tower.position.y = 140; // Start low
                tower.receiveShadow = true;
                this.towerGroup.add(tower);

                // 2. Player: Try Loading GLB
                this.loadPlayerModel();

                // 3. Platforms (Simple Boxes)
                for(let i=0; i<50; i++) {
                    this.addPlatform(i);
                }
            }

            // --- Auto-Fixer for 3D Models ---
            fitModelToSize(model, targetHeight) {
                // 1. Reset transforms to ensure calculation is clean
                model.updateWorldMatrix(true, true);
                
                // 2. Calculate box
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                
                // 3. Scale
                let scaleFactor = 1;
                if (size.y > 0) {
                    scaleFactor = targetHeight / size.y;
                }
                model.scale.set(scaleFactor, scaleFactor, scaleFactor);
                
                // 4. Recalculate box after scale to get correct centering offsets
                model.updateWorldMatrix(true, true);
                const scaledBox = new THREE.Box3().setFromObject(model);
                const center = scaledBox.getCenter(new THREE.Vector3());
                const bottomY = scaledBox.min.y;

                // 5. Create Wrapper
                const wrapper = new THREE.Group();
                wrapper.add(model);

                // 6. Reposition Model inside Wrapper so:
                // - Feet are at Y=0
                // - X and Z centers are at 0
                // Note: We use the negated center coordinates because we are moving the model relative to the wrapper origin
                model.position.x = -center.x;
                model.position.y = -bottomY;
                model.position.z = -center.z;

                return wrapper;
            }

            // --- Procedural Character Generator (Backup) ---
            generatePlayerTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 256, 256);
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.roundRect(64, 32, 128, 192, 60);
                ctx.fill();
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.roundRect(74, 80, 45, 30, 10);
                ctx.roundRect(137, 80, 45, 30, 10);
                ctx.fill();
                ctx.strokeStyle = '#111';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(119, 95);
                ctx.lineTo(137, 95);
                ctx.stroke();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.arc(128, 150, 30, 0.2, Math.PI - 0.2);
                ctx.stroke();
                return new THREE.CanvasTexture(canvas);
            }

            createProceduralPlayer() {
                const tex = this.generatePlayerTexture();
                const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
                const geo = new THREE.PlaneGeometry(2.5, 2.5);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(-1.5, 1.5 + SETTINGS.platformTopOffset, SETTINGS.zIndex); 
                mesh.onBeforeRender = (renderer, scene, camera) => {
                    mesh.quaternion.copy(camera.quaternion);
                };
                return mesh;
            }

            loadPlayerModel() {
                // Create backup first (Orange Sprite)
                this.player = this.createProceduralPlayer();
                this.scene.add(this.player);

                try {
                    this.gltfLoader.load(
                        'character.glb',
                        (gltf) => {
                            console.log("Model loaded successfully!");
                            
                            if(this.player) this.scene.remove(this.player);

                            // Run Auto-Fixer to normalize size and centering
                            // Returns a wrapper group with feet at (0,0,0) local
                            const fixedModel = this.fitModelToSize(gltf.scene, 2.5);
                            
                            this.player = fixedModel;
                            
                            // Position the wrapper:
                            // X: -1.5 (Left side)
                            // Y: platformTopOffset (On top of the 0.5 height platform)
                            // Z: zIndex (7.0, nicely in front of the tower)
                            this.player.position.set(-1.5, SETTINGS.platformTopOffset, SETTINGS.zIndex); 
                            
                            // ROTATION: Face the camera (Standard GLB faces -Z, Camera is at +Z)
                            this.player.rotation.y = Math.PI; 

                            this.player.traverse((node) => {
                                if (node.isMesh) {
                                    node.castShadow = true;
                                    node.receiveShadow = true;
                                }
                            });

                            this.scene.add(this.player);
                            document.getElementById('debug-area').innerText = ""; 
                        },
                        undefined, 
                        (error) => {
                            console.warn("GLB load failed:", error);
                            if (window.location.protocol === 'file:') {
                                document.getElementById('debug-area').innerHTML = "⚠️ Using Backup Sprite.<br>Reason: Browser blocked 3D file.<br>Solution: Use a Local Server.";
                            } else {
                                document.getElementById('debug-area').innerHTML = "⚠️ Using Backup Sprite.<br>Reason: character.glb not found.";
                            }
                        }
                    );
                } catch (e) {
                    console.warn("GLTFLoader exception:", e);
                }
            }

            addPlatform(level) {
                const geo = new THREE.BoxGeometry(3.5, 0.5, 3.5);
                const mat = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const platform = new THREE.Mesh(geo, mat);
                // Position platform at safe Z index (7.0)
                platform.position.set(0, level * SETTINGS.floorHeight, SETTINGS.zIndex);
                platform.castShadow = true;
                platform.receiveShadow = true;
                this.towerGroup.add(platform);
            }

            createCardObject(colorHex) {
                const geometry = new THREE.BoxGeometry(2.2, 3.2, 0.2);
                const material = new THREE.MeshStandardMaterial({ color: colorHex });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                return mesh;
            }

            spawnCard(cardData, isCurrent, floorIndex) {
                return null;
            }

            moveCameraToFloor(floorIndex) {
                const targetY = (floorIndex * SETTINGS.floorHeight) + SETTINGS.cameraOffset.y;
                new TWEEN.Tween(this.camera.position)
                    .to({ y: targetY }, SETTINGS.animationSpeed * 1.2)
                    .easing(TWEEN.Easing.Cubic.InOut)
                    .start();
            }

            playerJumpTo(floorIndex) {
                // Target Y is Floor Height + Offset
                const endY = (floorIndex * SETTINGS.floorHeight) + SETTINGS.platformTopOffset; 
                
                new TWEEN.Tween(this.player.position)
                    .to({ y: endY }, SETTINGS.animationSpeed)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();

                // Squash/Stretch effect on the wrapper
                new TWEEN.Tween(this.player.scale)
                    .to({ y: 0.8, x: 1.2, z: 1.2 }, SETTINGS.animationSpeed * 0.5)
                    .yoyo(true)
                    .repeat(1)
                    .start();
            }

            flipCard(cardMesh) {
                return new Promise(resolve => {
                    if (!cardMesh) {
                        resolve();
                        return;
                    }
                    new TWEEN.Tween(cardMesh.rotation)
                        .to({ y: 0 }, 300)
                        .easing(TWEEN.Easing.Linear.None)
                        .onComplete(resolve)
                        .start();
                });
            }
            
            clearOldCards(floorLimit) {
                const keepHeight = (floorLimit - 1) * SETTINGS.floorHeight;
                for(let i = this.cardGroup.children.length - 1; i >= 0; i--) {
                    if(this.cardGroup.children[i].position.y < keepHeight) {
                        this.cardGroup.remove(this.cardGroup.children[i]);
                    }
                }
            }
        }

        // --- Game Logic ---
        class GameLogic {
            constructor(engine) {
                this.engine = engine;
                this.deck = [];
                this.currentCard = null;
                this.nextCard = null;
                this.floor = 1;
                this.score = 0;
                
                this.currentCardMesh = null;
                this.nextCardMesh = null;

                this.initGame();
            }

            initGame() {
                this.floor = 1;
                this.score = 0;
                this.updateUI();
                
                this.generateDeck();
                this.currentCard = this.drawCard();
                this.nextCard = this.drawCard();

                if(this.engine.player) {
                    // Reset position: -1.5 X, Floor 0 + Offset Y, Z-Index 7.0
                    this.engine.player.position.set(-1.5, SETTINGS.platformTopOffset, SETTINGS.zIndex);
                }
                this.engine.camera.position.y = SETTINGS.cameraOffset.y;
                this.engine.cardGroup.clear();

                this.currentCardMesh = this.engine.spawnCard(this.currentCard, true, 0);
                this.nextCardMesh = this.engine.spawnCard(this.nextCard, false, 0);

                this.updateCardUI();
                this.setPhase('guess');
            }

            generateDeck() {
                const suits = [
                    { s: '♥', c: '#ef4444' }, 
                    { s: '♦', c: '#ef4444' }, 
                    { s: '♣', c: '#111827' }, 
                    { s: '♠', c: '#111827' }
                ];
                const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                this.deck = [];
                for(let d=0; d<5; d++) {
                    for (const suit of suits) {
                        for (let i = 0; i < ranks.length; i++) {
                            this.deck.push({
                                rank: ranks[i],
                                value: i + 2,
                                suitIcon: suit.s,
                                color: suit.c
                            });
                        }
                    }
                }
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            drawCard() {
                if(this.deck.length === 0) this.generateDeck();
                return this.deck.pop();
            }

            async playerGuess(choice) {
                this.setPhase('locked');
                await this.engine.flipCard(this.nextCardMesh);
                this.updateCardUI(true); 

                const currentVal = this.currentCard.value;
                const nextVal = this.nextCard.value;
                let won = false;

                if (choice === 'higher' && nextVal >= currentVal) won = true;
                else if (choice === 'lower' && nextVal <= currentVal) won = true;

                if (won) {
                    setTimeout(() => this.handleWin(), 300);
                } else {
                    setTimeout(() => this.handleLoss(), 500);
                }
            }

            handleWin() {
                this.showMessage("CORRECT!", false);
                this.score += 100 * this.floor;
                this.floor++;
                
                this.engine.playerJumpTo(this.floor - 1);
                this.engine.moveCameraToFloor(this.floor - 1);
                
                this.updateUI();
                setTimeout(() => {
                    this.setupNextRound();
                }, SETTINGS.animationSpeed + 100);
            }

            handleLoss() {
                this.showMessage("FAILED!", true);
                this.setPhase('gameover');
            }

            setupNextRound() {
                this.currentCard = this.nextCard;
                if (this.nextCardMesh) {
                    this.engine.cardGroup.remove(this.nextCardMesh);
                    this.nextCardMesh = null;
                }
                
                this.nextCard = this.drawCard();
                const floorIdx = this.floor - 1;
                
                this.nextCardMesh = this.engine.spawnCard(this.nextCard, false, floorIdx);
                this.engine.clearOldCards(this.floor);
                
                this.updateCardUI(false); 
                this.setPhase('guess');
            }
            
            resetGame() {
                this.initGame();
            }

            updateCardUI(revealNext = false) {
                const c = this.currentCard;
                const cEl = document.getElementById('ui-card-current');
                cEl.className = `card-ui transform -rotate-6 ${c.color === '#ef4444' ? 'red' : 'black'}`;
                cEl.innerHTML = `
                    <div class="text-xl">${c.rank}</div>
                    <div class="text-3xl text-center">${c.suitIcon}</div>
                    <div class="text-xl self-end rotate-180">${c.rank}</div>
                `;

                const nEl = document.getElementById('ui-card-next');
                if (revealNext) {
                    const n = this.nextCard;
                    nEl.className = `card-ui transform rotate-6 ${n.color === '#ef4444' ? 'red' : 'black'}`;
                    nEl.innerHTML = `
                        <div class="text-xl">${n.rank}</div>
                        <div class="text-3xl text-center">${n.suitIcon}</div>
                        <div class="text-xl self-end rotate-180">${n.rank}</div>
                    `;
                } else {
                    nEl.className = 'card-ui back transform rotate-6';
                    nEl.innerHTML = '?';
                }
            }

            showMessage(text, isBad = false) {
                const el = document.getElementById('game-message');
                el.innerText = text;
                el.style.color = isBad ? '#ff4444' : '#4ade80';
                el.style.opacity = 1;
                el.style.transform = 'scale(1)';
                setTimeout(() => {
                    el.style.opacity = 0;
                    el.style.transform = 'scale(0.5)';
                }, 1000);
            }

            updateUI() {
                document.getElementById('floor-display').innerText = this.floor;
                document.getElementById('score-display').innerText = this.score;
                document.getElementById('final-floor').innerText = this.floor;
            }

            setPhase(phase) {
                const guessControls = document.getElementById('controls-guess');
                const resetControls = document.getElementById('controls-reset');

                guessControls.classList.add('hidden');
                resetControls.classList.add('hidden');

                if (phase === 'guess') {
                    guessControls.classList.remove('hidden');
                } else if (phase === 'gameover') {
                    resetControls.classList.remove('hidden');
                }
            }
        }

        const engine = new GameEngine();
        engine.initWorld();
        const game = new GameLogic(engine);

    </script>
</body>
</html>
